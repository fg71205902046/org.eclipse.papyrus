/*****************************************************************************
 * Copyright (c) 2020 CEA LIST, EclipseSource and others.
 *
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License 2.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 *
 * Contributors:
 *   Remi Schnekenburger (EclipseSource) - Initial API and implementation
 *
 *****************************************************************************/
package org.eclipse.papyrus.toolsmiths.validation.profile.internal.checkers;

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Objects;

import org.eclipse.core.resources.IFile;
import org.eclipse.core.runtime.IPath;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.emf.common.util.URI;
import org.eclipse.emf.ecore.resource.impl.URIMappingRegistryImpl;
import org.eclipse.emf.ecore.xmi.XMIResource;
import org.eclipse.osgi.util.NLS;
import org.eclipse.papyrus.toolsmiths.validation.common.utils.ProjectManagementService;
import org.eclipse.papyrus.toolsmiths.validation.profile.Activator;
import org.eclipse.papyrus.toolsmiths.validation.profile.constants.ProfilePluginValidationConstants;
import org.eclipse.papyrus.toolsmiths.validation.profile.internal.messages.Messages;
import org.eclipse.papyrus.uml.tools.model.UmlModel;
import org.eclipse.papyrus.uml.tools.utils.StaticProfileUtil;
import org.eclipse.pde.core.build.IBuild;
import org.eclipse.pde.core.build.IBuildEntry;
import org.eclipse.pde.core.build.IBuildModel;
import org.eclipse.pde.internal.core.builders.CompilerFlags;
import org.eclipse.pde.internal.core.builders.IncrementalErrorReporter.VirtualMarker;
import org.eclipse.pde.internal.core.builders.PluginBaseErrorReporter;
import org.eclipse.pde.internal.core.builders.XMLErrorReporter;
import org.eclipse.uml2.uml.Profile;
import org.w3c.dom.Element;
import org.w3c.dom.Node;

/**
 * Error reporter for specific extensions for static profiles.
 */
@SuppressWarnings("restriction")
public class StaticProfilePluginErrorReporter extends PluginBaseErrorReporter {

	/** Problem IDs for the markers generated by this error reporter. */
	public static final int NO_GENMODEL_MARKER_ID = 0xff1001;
	public static final int PAPYRUS_PROFILE_EXTENSION_NO_NAME_MARKER_ID = 0xff1002;
	public static final int MISSING_UML_EXTENSION_MARKER_ID = 0xff1003;
	public static final int NO_URI_MARKER_ID = 0xff1004;
	public static final int NO_ECORE_GEN_PACKAGE_MARKER_ID = 0xff1005;
	public static final int NO_UML2_GEN_PACKAGE_MARKER_ID = 0xff1006;
	public static final int NO_PAPYRUS_PROFILE_MARKER_ID = 0xff1007;
	public static final int NO_UML2_GEN_PACKAGE_LOCATION_MARKER_ID = 0xff1008;
	public static final int MISSING_FROM_BINARY_BUILD_MARKER_ID = 0xff1009;

	/** Attributes of markers created by this error reporter */
	public static final String STATIC_PROFILE_STEREOTYPE_URI = "staticProfileStereotypeUri"; //$NON-NLS-1$
	public static final String STATIC_PROFILE_MARKER_ATTRIBUTE = "staticProfile"; //$NON-NLS-1$
	public static final String STATIC_PROFILE_BINARY_BUILD_PATH = "binaryBuildPath"; //$NON-NLS-1$

	private static final String NAME = "name"; //$NON-NLS-1$
	private static final String PATH = "path"; //$NON-NLS-1$
	private static final String LOCATION = "location"; //$NON-NLS-1$
	private static final String URI = "uri"; //$NON-NLS-1$
	private static final String GEN_MODEL_ATTRIBUTE = "genModel"; //$NON-NLS-1$
	private static final String PACKAGE = "package"; //$NON-NLS-1$
	private static final String ICONPATH = "iconpath"; //$NON-NLS-1$
	private static final String MAPPING = "mapping"; //$NON-NLS-1$
	private static final String GENMODEL_EXTENSION = "genmodel"; //$NON-NLS-1$
	private static final String PROFILE = "profile"; //$NON-NLS-1$
	private static final String TARGET = "target"; //$NON-NLS-1$
	private static final String SOURCE = "source"; //$NON-NLS-1$
	private static final String POINT = "point"; //$NON-NLS-1$

	private static final String PATHMAP = "pathmap://"; //$NON-NLS-1$
	private static final String PLATFORM_PLUGIN = "platform:/plugin/"; //$NON-NLS-1$

	private static final String STATIC_PROFILE_CATEGORY = "Papyrus-staticProfile";//$NON-NLS-1$

	private static final String PATH_SEPARATOR = "/"; //$NON-NLS-1$
	private static final String ID_SEPARATOR = "_"; //$NON-NLS-1$


	private final List<String> foundPoints = new ArrayList<>();

	private final Map<String, String> localURIMappings = new HashMap<>();

	private Profile profile;
	private IFile profileFile;

	private String sourceID;

	private List<Element> papyrusProfileExtensions = new ArrayList<>();

	/**
	 * Constructor.
	 *
	 * @param file
	 *            the plugin.xml file
	 * @param profile
	 *            the profile model element
	 * @param profileFile
	 *            the profile containing file.
	 */
	public StaticProfilePluginErrorReporter(IFile file, Profile profile, IFile profileFile) {
		super(file);
		this.profile = profile;
		this.fFile = file;
		this.profileFile = profileFile;
		sourceID = sourceID(profileFile, profile);
		replaceReporter(this, file);

	}

	/**
	 * Replace the reporter created by default on abstract class, to implement our specific one.
	 *
	 * @see SelectiveDeleteErrorReporter.
	 */
	private void replaceReporter(StaticProfilePluginErrorReporter reporter, IFile file) {
		Field errorReporterField;
		try {
			errorReporterField = XMLErrorReporter.class.getDeclaredField("fErrorReporter"); //$NON-NLS-1$
			errorReporterField.setAccessible(true);
			Field modifiersField = Field.class.getDeclaredField("modifiers");//$NON-NLS-1$
			modifiersField.setAccessible(true);
			modifiersField.setInt(modifiersField, modifiersField.getModifiers() & ~Modifier.FINAL);
			errorReporterField.set(reporter, new SelectiveDeleteErrorReporter(file, sourceID));
		} catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException e) {
			Activator.log.error(e);
		}

	}

	/**
	 * Returns a unique id for the specified profile model element in the given profile file.
	 *
	 * @param file
	 *            the profile file
	 * @param profile
	 *            the profile model element
	 * @return the unique identifier for this profile in the plugin, which will allow to identify markers associated to this profile on the plugin.xml
	 */
	private static String sourceID(IFile file, Profile profile) {
		StringBuilder builder = new StringBuilder();
		builder.append("staticprofile"); //$NON-NLS-1$
		builder.append(ID_SEPARATOR);
		builder.append(file.getProjectRelativePath().toString());
		builder.append(ID_SEPARATOR);
		String name = profile.getQualifiedName();
		builder.append(name);
		return builder.toString();
	}

	@Override
	protected String getRootElementName() {
		return "plugin"; //$NON-NLS-1$
	}

	@Override
	public void validate(IProgressMonitor monitor) {
		super.validate(monitor);

		postValidatePapyrusExtensions();

		// now check the found extensions and throw error for inexisting ones
		if (!foundPoints.contains(ProfilePluginValidationConstants.ECORE_GENERATED_PACKAGE_EXTENSION_POINT)) {
			reportNoEcoreGeneratedPackage();
		}
		if (!foundPoints.contains(ProfilePluginValidationConstants.UML_GENERATED_PACKAGE_EXTENSION_POINT)) {
			reportNoUML2GeneratedPackage();
		}
		if (!foundPoints.contains(ProfilePluginValidationConstants.UMLPROFILE_EXTENSION_POINT)) {
			if (profile.getNestingPackage() == null) {
				reportNoPapyrusProfile();
			}
		}
	}

	/**
	 * Validate the specific static profile extensions once the validation has visited all extensions in the plugin.xml file.
	 */
	private void postValidatePapyrusExtensions() {
		if (profile.getNestingPackage() != null) {
			return;
		}

		String profilePath = profileFile.getProjectRelativePath().removeFileExtension().addFileExtension(UmlModel.UML_FILE_EXTENSION).toString();

		for (Element papyrusProfileExtension : papyrusProfileExtensions) {
			String name = papyrusProfileExtension.getAttribute(NAME);
			String path = decodePath(papyrusProfileExtension.getAttribute(PATH));
			// check path
			if (!profilePath.equals(path)) {
				continue;
			}
			foundPoints.add(ProfilePluginValidationConstants.UMLPROFILE_EXTENSION_POINT);
			// UI name shall not be null
			if (name == null || name.isEmpty()) {
				VirtualMarker marker = report(NLS.bind(Messages.StaticProfilePluginErrorReporter_uiLabelIsNull, profile.getLabel()), getLine(papyrusProfileExtension, NAME), CompilerFlags.ERROR, PAPYRUS_PROFILE_EXTENSION_NO_NAME_MARKER_ID,
						papyrusProfileExtension, NAME,
						STATIC_PROFILE_CATEGORY);
				addMarkerAttribute(marker, STATIC_PROFILE_MARKER_ATTRIBUTE, profile.getLabel());
			}

			// make sure icon is in the binary build
			String iconPath = papyrusProfileExtension.getAttribute(ICONPATH);
			if (iconPath != null && !iconPath.isBlank()) {
				IFile iconFile = profileFile.getProject().getFile(iconPath);
				if (iconFile.exists() && !binaryBuildContains(iconFile.getProjectRelativePath())) {
					VirtualMarker marker = addErrorMarker(papyrusProfileExtension, ICONPATH, NLS.bind(Messages.StaticProfilePluginErrorReporter_resourceMissingFromBinaryBuild, iconPath), MISSING_FROM_BINARY_BUILD_MARKER_ID);
					marker.setAttribute(STATIC_PROFILE_BINARY_BUILD_PATH, iconPath);
				}
			}
		}
	}

	private boolean binaryBuildContains(IPath path) {
		final IBuildModel buildModel = ProjectManagementService.getPluginBuild(profileFile.getProject());
		final IBuild build = buildModel.getBuild();
		final IBuildEntry buildEntry = build.getEntry(IBuildEntry.BIN_INCLUDES);
		final String[] tokens = buildEntry.getTokens();

		if (path.segmentCount() > 1) {
			String containingFolder = path.removeLastSegments(1).addTrailingSeparator().toString();
			boolean foundFolder = Arrays.stream(tokens).anyMatch(containingFolder::equals);
			if (foundFolder) {
				return true;
			}
		}
		return Arrays.stream(tokens).anyMatch(path.toString()::equals);
	}

	/**
	 * Reports that no ECore generated package was found for the current profile.
	 */
	private void reportNoEcoreGeneratedPackage() {
		VirtualMarker marker = reportForProfile(NLS.bind(Messages.StaticProfilePluginErrorReporter_noEcoreGeneratedPackageFound, profile.getLabel()), 1, CompilerFlags.ERROR, NO_ECORE_GEN_PACKAGE_MARKER_ID, STATIC_PROFILE_CATEGORY);
		addMarkerAttribute(marker, STATIC_PROFILE_MARKER_ATTRIBUTE, profile.getLabel());
	}

	private VirtualMarker reportForProfile(String message, int line, int severity, int fixId, String category) {
		VirtualMarker marker = report(message, line, severity, fixId, category);
		addMarkerID(marker);
		return marker;
	}

	private void addMarkerID(VirtualMarker marker) {
		if (marker == null) {
			return;
		}
		addMarkerAttribute(marker, SelectiveDeleteErrorReporter.SOURCE_ID, sourceID);
	}

	/**
	 * Reports that no UML2 generated package was found for the current profile.
	 */
	private void reportNoUML2GeneratedPackage() {
		VirtualMarker marker = reportForProfile(NLS.bind(Messages.StaticProfilePluginErrorReporter_noUML2GeneratedPackage, profile.getLabel()), 1, CompilerFlags.ERROR, NO_UML2_GEN_PACKAGE_MARKER_ID, STATIC_PROFILE_CATEGORY);
		addMarkerAttribute(marker, STATIC_PROFILE_MARKER_ATTRIBUTE, profile.getLabel());
	}

	/**
	 * Reports that no Papyrus profile extension was found for the current profile.
	 */
	private void reportNoPapyrusProfile() {
		VirtualMarker marker = reportForProfile(NLS.bind(Messages.StaticProfilePluginErrorReporter_NoPapyrusProfileExtensionFound, profile.getLabel()), 1, CompilerFlags.WARNING, NO_PAPYRUS_PROFILE_MARKER_ID, STATIC_PROFILE_CATEGORY);
		addMarkerAttribute(marker, STATIC_PROFILE_MARKER_ATTRIBUTE, profile.getLabel());
	}

	@Override
	protected void validateExtension(Element element) {
		// do not let default validation be done, this will be done by standard plugin builder
		String pointID = element.getAttribute(POINT);
		// find the correct checker
		switch (pointID) {
		case ProfilePluginValidationConstants.ECORE_GENERATED_PACKAGE_EXTENSION_POINT:
			if (foundPoints.contains(ProfilePluginValidationConstants.ECORE_GENERATED_PACKAGE_EXTENSION_POINT)) {
				// already found the extension that should be checked, so avoid checking others.
				break;
			}
			// check if this is the correct profile to test
			checkEcoreGeneratedPackage(element);
			break;
		case ProfilePluginValidationConstants.UML_GENERATED_PACKAGE_EXTENSION_POINT:
			if (foundPoints.contains(ProfilePluginValidationConstants.UML_GENERATED_PACKAGE_EXTENSION_POINT)) {
				break;
			}
			checkUML2GeneratedPackage(element);
			break;
		case ProfilePluginValidationConstants.UMLPROFILE_EXTENSION_POINT:
			if (foundPoints.contains(ProfilePluginValidationConstants.UMLPROFILE_EXTENSION_POINT)) {
				break;
			}
			checkPapyrusProfile(element);
			break;
		case ProfilePluginValidationConstants.ECORE_URI_MAPPING_EXTENSION_POINT:
			collectMapping(element);
			break;
		default:
			break;
		}

	}

	private void collectMapping(Element element) {
		for (int i = 0; i < element.getChildNodes().getLength(); i++) {
			Node node = element.getChildNodes().item(i);
			if (node instanceof Element && MAPPING.equals(((Element) node).getNodeName())) {
				Element profileElement = (Element) node;
				String sourceURI = profileElement.getAttribute(SOURCE);
				String targetURI = profileElement.getAttribute(TARGET);
				localURIMappings.put(sourceURI, targetURI);
			}
		}
	}

	private void checkPapyrusProfile(Element element) {
		/*
		 * <extension point="org.eclipse.papyrus.uml.extensionpoints.UMLProfile">
		 * <profile
		 * description="UML profile for SysML (from OMG SysML V1.4)"
		 * iconpath="resources/icons/SysMLProfile.gif"
		 * name="SysML 1.4"
		 * path="pathmap://SysML14_PROFILES/SysML.profile.uml"
		 * provider="Eclipse Modeling Project">
		 * </profile>
		 * </extension>
		 */
		// should check only for root profiles
		if (profile.getNestingPackage() != null) {
			return;
		}

		for (int i = 0; i < element.getChildNodes().getLength(); i++) {
			Node node = element.getChildNodes().item(i);
			if (node instanceof Element && PROFILE.equals(((Element) node).getNodeName())) {
				papyrusProfileExtensions.add((Element) node);
			}
		}

	}

	private void checkUML2GeneratedPackage(Element element) {
		/*
		 * <extension point="org.eclipse.uml2.uml.generated_package">
		 * <profile uri="http://www.eclipse.org/papyrus/sysml/1.4/SysML"
		 * location="pathmap://SysML14_PROFILES/SysML.profile.uml#SysML"/>
		 * <profile
		 * location="pathmap://SysML14_PROFILES/SysML.profile.uml#SysML.package_packagedElement_Activities"
		 * uri="http://www.eclipse.org/papyrus/sysml/1.4/SysML/Activities">
		 * </profile>
		 */
		String stereotypeNsURI = profileURI(profile);
		if (stereotypeNsURI == null || stereotypeNsURI.isBlank()) {
			// can't check this profile
			return;
		}
		for (int i = 0; i < element.getChildNodes().getLength(); i++) {
			Node node = element.getChildNodes().item(i);
			if (node instanceof Element && PROFILE.equals(((Element) node).getNodeName())) {
				Element profileElement = (Element) node;
				String extensionNsURI = profileElement.getAttribute(URI);
				if (extensionNsURI == null || extensionNsURI.isBlank()) {
					VirtualMarker marker = addErrorMarker(profileElement, URI, NLS.bind(Messages.StaticProfilePluginErrorReporter_missingExtensionPointAttribute, URI), NO_URI_MARKER_ID);
					marker.setAttribute(STATIC_PROFILE_STEREOTYPE_URI, stereotypeNsURI);
				}
				String extensionlocation = profileElement.getAttribute(LOCATION);
				if (extensionlocation == null || extensionlocation.isBlank()) {
					addErrorMarker(profileElement, LOCATION, NLS.bind(Messages.StaticProfilePluginErrorReporter_missingExtensionPointAttribute, LOCATION), NO_UML2_GEN_PACKAGE_LOCATION_MARKER_ID);
				}
				// check this is the good extension point => genmodel should match first
				if (Objects.equals(stereotypeNsURI, extensionNsURI)) {
					foundPoints.add(ProfilePluginValidationConstants.UML_GENERATED_PACKAGE_EXTENSION_POINT);

					final String profileId = ((XMIResource) profile.eResource()).getID(profile);
					String uml2ProfileFile = profileFile.getProjectRelativePath().removeFileExtension().addFileExtension(UmlModel.UML_FILE_EXTENSION).lastSegment();

					if (!extensionlocation.endsWith(uml2ProfileFile + "#" + profileId)) { //$NON-NLS-1$
						addErrorMarker(profileElement, LOCATION, NLS.bind(Messages.StaticProfilePluginErrorReporter_wrongLocationForProfile, profile.getLabel()), MISSING_UML_EXTENSION_MARKER_ID);
					}
				}
			}
		}

	}

	private VirtualMarker reportForProfile(String message, int line, int severity, int fixId, Element element, String attrName,
			String category) {
		VirtualMarker marker = report(message, line, severity, fixId, element, attrName, category);
		addMarkerID(marker);
		return marker;
	}

	private void checkEcoreGeneratedPackage(Element element) {
		for (int i = 0; i < element.getChildNodes().getLength(); i++) {
			Node node = element.getChildNodes().item(i);
			if (node instanceof Element && PACKAGE.equals(((Element) node).getNodeName())) {
				Element packageElement = (Element) node;
				String extensionGenModel = packageElement.getAttribute(GEN_MODEL_ATTRIBUTE);

				// genmodel should be set
				if (extensionGenModel == null || extensionGenModel.isBlank()) {
					addErrorMarker(packageElement, GEN_MODEL_ATTRIBUTE, NLS.bind(Messages.StaticProfilePluginErrorReporter_missingExtensionPointAttribute, GEN_MODEL_ATTRIBUTE), NO_GENMODEL_MARKER_ID);
					return;
				}

				// retrieve profile file path and compare with given path in extension point
				IPath projectRelativePath = profileFile.getProjectRelativePath();
				IPath genModelFilePath = projectRelativePath.removeFileExtension().addFileExtension(GENMODEL_EXTENSION);
				String genModelFile = genModelFilePath.toString();
				// compare with profile genmodel
				if (!Objects.equals(genModelFile, extensionGenModel)) {
					// different profile, return
					return;
				}

				boolean genModelEntryFound = binaryBuildContains(genModelFilePath);
				if (!genModelEntryFound) {
					VirtualMarker marker = addErrorMarker(packageElement, GEN_MODEL_ATTRIBUTE, NLS.bind(Messages.StaticProfilePluginErrorReporter_resourceMissingFromBinaryBuild, genModelFile), MISSING_FROM_BINARY_BUILD_MARKER_ID);
					marker.setAttribute(STATIC_PROFILE_BINARY_BUILD_PATH, genModelFile);
				}
				String stereotypeNsURI = profileURI(profile);

				// uri should be set
				String extensionNsURI = packageElement.getAttribute(URI);
				if (extensionNsURI == null || extensionNsURI.isBlank()) {
					VirtualMarker marker = addErrorMarker(packageElement, URI, NLS.bind(Messages.StaticProfilePluginErrorReporter_missingExtensionPointAttribute, URI), NO_URI_MARKER_ID);
					marker.setAttribute(STATIC_PROFILE_STEREOTYPE_URI, stereotypeNsURI);
					return;
				}

				// compare URI with profile uri in stereotype ecore::epackage
				if (Objects.equals(stereotypeNsURI, extensionNsURI)) {
					foundPoints.add(ProfilePluginValidationConstants.ECORE_GENERATED_PACKAGE_EXTENSION_POINT);
				}
			}
		}
	}

	private VirtualMarker addErrorMarker(Element element, String attribute, String message, int problemId) {
		VirtualMarker marker = reportForProfile(message,
				getLine(element, attribute), CompilerFlags.ERROR, problemId, element, attribute, STATIC_PROFILE_CATEGORY);
		addMarkerAttribute(marker, STATIC_PROFILE_MARKER_ATTRIBUTE, profile.getLabel());
		return marker;
	}

	@Override
	protected int getLine(Element element, String attName) {
		// when multiple elements with the same name exist,
		// an incorrect line is returned from the super call if the attribute does not exist in the element
		if (element.hasAttribute(attName)) {
			return super.getLine(element, attName);
		}
		return getLine(element);
	}

	private static String profileURI(Profile profile) {
		return new StaticProfileUtil(profile).getDefinition().getNsURI();
	}

	private String decodePath(String path) {
		if (path == null) {
			return null;
		}

		// check pathmap, relative URI or platform based uri
		if (path.startsWith(PATHMAP)) {
			// try to decode using uri mappers extensions
			return decodePathmapPath(path);
		} else if (path.startsWith(PLATFORM_PLUGIN)) {
			// check if path is valid within the plugin
			return decodePlatformPath(path);
		}

		// relative path?
		return path;
	}

	private String decodePlatformPath(String path) {
		return cutPluginPath(path);
	}

	private String decodePathmapPath(String path) {
		String decodePath = null;
		// check first local mappings
		for (Entry<String, String> entry : localURIMappings.entrySet()) {
			String sourceURI = entry.getKey().toString();
			if (path.startsWith(sourceURI)) {
				String targetURI = entry.getValue();
				decodePath = replaceString(path, sourceURI, targetURI);
				return cutPluginPath(decodePath);
			}
		}
		for (Entry<URI, URI> entry : URIMappingRegistryImpl.INSTANCE.entrySet()) {
			String sourceURI = entry.getKey().toString();
			if (path.startsWith(sourceURI)) {
				String targetURI = entry.getValue().toString();
				decodePath = replaceString(path, sourceURI, targetURI);
				return cutPluginPath(decodePath);
			}
		}

		// cut platform:/plugin/<profile-name> to get a project relative path
		return path;
	}

	private String cutPluginPath(String decodePath) {
		if (decodePath.startsWith(PLATFORM_PLUGIN)) {
			String cutPath = decodePath.substring(PLATFORM_PLUGIN.length());
			int index = cutPath.indexOf(PATH_SEPARATOR);
			cutPath = cutPath.substring(index + 1); // remove initial '/'
			return cutPath;
		}
		return decodePath;
	}

	private String replaceString(String path, String sourceURI, String targetURI) {
		String newPath = path.substring(sourceURI.length(), path.length());
		if (!targetURI.endsWith(PATH_SEPARATOR)) {
			newPath = PATH_SEPARATOR.concat(newPath);
		}
		newPath = targetURI.concat(newPath);
		return newPath;
	}

}
